// Code generated by Prisma (prisma@1.18.0-beta). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { GraphQLSchema } from 'graphql';
import { IResolvers } from 'graphql-tools/dist/Interfaces';
import { makePrismaClientClass, BaseClientOptions } from 'prisma-client-lib';
import { typeDefs } from './prisma-schema';

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  knex_migrations: (where?: Knex_migrationsWhereInput) => Promise<boolean>;
  knex_migrations_lock: (
    where?: Knex_migrations_lockWhereInput,
  ) => Promise<boolean>;
  users: (where?: UsersWhereInput) => Promise<boolean>;
}

export interface Node {}

export interface Fragmentable {
  $fragment<T>(fragment: string | Object): T;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any },
  ) => Promise<T>;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  knex_migrations: (where: Knex_migrationsWhereUniqueInput) => Knex_migrations;
  knex_migrationses: (
    args?: {
      where?: Knex_migrationsWhereInput;
      orderBy?: Knex_migrationsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
  ) => Promise<Array<Knex_migrationsNode>>;
  knex_migrationsesConnection: (
    args?: {
      where?: Knex_migrationsWhereInput;
      orderBy?: Knex_migrationsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
  ) => Knex_migrationsConnection;
  knex_migrations_lock: (
    where: Knex_migrations_lockWhereUniqueInput,
  ) => Knex_migrations_lock;
  knex_migrations_locks: (
    args?: {
      where?: Knex_migrations_lockWhereInput;
      orderBy?: Knex_migrations_lockOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
  ) => Promise<Array<Knex_migrations_lockNode>>;
  knex_migrations_locksConnection: (
    args?: {
      where?: Knex_migrations_lockWhereInput;
      orderBy?: Knex_migrations_lockOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
  ) => Knex_migrations_lockConnection;
  users: (where: UsersWhereUniqueInput) => Users;
  userses: (
    args?: {
      where?: UsersWhereInput;
      orderBy?: UsersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
  ) => Promise<Array<UsersNode>>;
  usersesConnection: (
    args?: {
      where?: UsersWhereInput;
      orderBy?: UsersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    },
  ) => UsersConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createKnex_migrations: (data: Knex_migrationsCreateInput) => Knex_migrations;
  updateKnex_migrations: (
    args: {
      data: Knex_migrationsUpdateInput;
      where: Knex_migrationsWhereUniqueInput;
    },
  ) => Knex_migrations;
  updateManyKnex_migrationses: (
    args: {
      data: Knex_migrationsUpdateInput;
      where?: Knex_migrationsWhereInput;
    },
  ) => BatchPayload;
  upsertKnex_migrations: (
    args: {
      where: Knex_migrationsWhereUniqueInput;
      create: Knex_migrationsCreateInput;
      update: Knex_migrationsUpdateInput;
    },
  ) => Knex_migrations;
  deleteKnex_migrations: (
    where: Knex_migrationsWhereUniqueInput,
  ) => Knex_migrations;
  deleteManyKnex_migrationses: (
    where?: Knex_migrationsWhereInput,
  ) => BatchPayload;
  createKnex_migrations_lock: (
    data: Knex_migrations_lockCreateInput,
  ) => Knex_migrations_lock;
  updateKnex_migrations_lock: (
    args: {
      data: Knex_migrations_lockUpdateInput;
      where: Knex_migrations_lockWhereUniqueInput;
    },
  ) => Knex_migrations_lock;
  updateManyKnex_migrations_locks: (
    args: {
      data: Knex_migrations_lockUpdateInput;
      where?: Knex_migrations_lockWhereInput;
    },
  ) => BatchPayload;
  upsertKnex_migrations_lock: (
    args: {
      where: Knex_migrations_lockWhereUniqueInput;
      create: Knex_migrations_lockCreateInput;
      update: Knex_migrations_lockUpdateInput;
    },
  ) => Knex_migrations_lock;
  deleteKnex_migrations_lock: (
    where: Knex_migrations_lockWhereUniqueInput,
  ) => Knex_migrations_lock;
  deleteManyKnex_migrations_locks: (
    where?: Knex_migrations_lockWhereInput,
  ) => BatchPayload;
  createUsers: (data: UsersCreateInput) => Users;
  updateUsers: (
    args: { data: UsersUpdateInput; where: UsersWhereUniqueInput },
  ) => Users;
  updateManyUserses: (
    args: { data: UsersUpdateInput; where?: UsersWhereInput },
  ) => BatchPayload;
  upsertUsers: (
    args: {
      where: UsersWhereUniqueInput;
      create: UsersCreateInput;
      update: UsersUpdateInput;
    },
  ) => Users;
  deleteUsers: (where: UsersWhereUniqueInput) => Users;
  deleteManyUserses: (where?: UsersWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  knex_migrations: (
    where?: Knex_migrationsSubscriptionWhereInput,
  ) => Knex_migrationsSubscriptionPayloadSubscription;
  knex_migrations_lock: (
    where?: Knex_migrations_lockSubscriptionWhereInput,
  ) => Knex_migrations_lockSubscriptionPayloadSubscription;
  users: (
    where?: UsersSubscriptionWhereInput,
  ) => UsersSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Knex_migrationsOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'batch_ASC'
  | 'batch_DESC'
  | 'migration_time_ASC'
  | 'migration_time_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type Knex_migrations_lockOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'is_locked_ASC'
  | 'is_locked_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED';

export type UsersOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'created_at_ASC'
  | 'created_at_DESC'
  | 'email_ASC'
  | 'email_DESC'
  | 'first_name_ASC'
  | 'first_name_DESC'
  | 'last_name_ASC'
  | 'last_name_DESC'
  | 'updated_at_ASC'
  | 'updated_at_DESC'
  | 'username_ASC'
  | 'username_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export interface Knex_migrations_lockCreateInput {
  is_locked?: Int;
}

export interface UsersWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  first_name?: String;
  first_name_not?: String;
  first_name_in?: String[] | String;
  first_name_not_in?: String[] | String;
  first_name_lt?: String;
  first_name_lte?: String;
  first_name_gt?: String;
  first_name_gte?: String;
  first_name_contains?: String;
  first_name_not_contains?: String;
  first_name_starts_with?: String;
  first_name_not_starts_with?: String;
  first_name_ends_with?: String;
  first_name_not_ends_with?: String;
  last_name?: String;
  last_name_not?: String;
  last_name_in?: String[] | String;
  last_name_not_in?: String[] | String;
  last_name_lt?: String;
  last_name_lte?: String;
  last_name_gt?: String;
  last_name_gte?: String;
  last_name_contains?: String;
  last_name_not_contains?: String;
  last_name_starts_with?: String;
  last_name_not_starts_with?: String;
  last_name_ends_with?: String;
  last_name_not_ends_with?: String;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  AND?: UsersWhereInput[] | UsersWhereInput;
  OR?: UsersWhereInput[] | UsersWhereInput;
  NOT?: UsersWhereInput[] | UsersWhereInput;
}

export interface Knex_migrations_lockWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  is_locked?: Int;
  is_locked_not?: Int;
  is_locked_in?: Int[] | Int;
  is_locked_not_in?: Int[] | Int;
  is_locked_lt?: Int;
  is_locked_lte?: Int;
  is_locked_gt?: Int;
  is_locked_gte?: Int;
  AND?: Knex_migrations_lockWhereInput[] | Knex_migrations_lockWhereInput;
  OR?: Knex_migrations_lockWhereInput[] | Knex_migrations_lockWhereInput;
  NOT?: Knex_migrations_lockWhereInput[] | Knex_migrations_lockWhereInput;
}

export type Knex_migrationsWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface Knex_migrationsWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  batch?: Int;
  batch_not?: Int;
  batch_in?: Int[] | Int;
  batch_not_in?: Int[] | Int;
  batch_lt?: Int;
  batch_lte?: Int;
  batch_gt?: Int;
  batch_gte?: Int;
  migration_time?: DateTimeInput;
  migration_time_not?: DateTimeInput;
  migration_time_in?: DateTimeInput[] | DateTimeInput;
  migration_time_not_in?: DateTimeInput[] | DateTimeInput;
  migration_time_lt?: DateTimeInput;
  migration_time_lte?: DateTimeInput;
  migration_time_gt?: DateTimeInput;
  migration_time_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: Knex_migrationsWhereInput[] | Knex_migrationsWhereInput;
  OR?: Knex_migrationsWhereInput[] | Knex_migrationsWhereInput;
  NOT?: Knex_migrationsWhereInput[] | Knex_migrationsWhereInput;
}

export interface Knex_migrationsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: Knex_migrationsWhereInput;
  AND?:
    | Knex_migrationsSubscriptionWhereInput[]
    | Knex_migrationsSubscriptionWhereInput;
  OR?:
    | Knex_migrationsSubscriptionWhereInput[]
    | Knex_migrationsSubscriptionWhereInput;
  NOT?:
    | Knex_migrationsSubscriptionWhereInput[]
    | Knex_migrationsSubscriptionWhereInput;
}

export interface UsersCreateInput {
  created_at: DateTimeInput;
  email?: String;
  first_name?: String;
  last_name?: String;
  updated_at: DateTimeInput;
  username?: String;
}

export type UsersWhereUniqueInput = AtLeastOne<{
  id: Int;
  email?: String;
  username?: String;
}>;

export interface Knex_migrations_lockSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: Knex_migrations_lockWhereInput;
  AND?:
    | Knex_migrations_lockSubscriptionWhereInput[]
    | Knex_migrations_lockSubscriptionWhereInput;
  OR?:
    | Knex_migrations_lockSubscriptionWhereInput[]
    | Knex_migrations_lockSubscriptionWhereInput;
  NOT?:
    | Knex_migrations_lockSubscriptionWhereInput[]
    | Knex_migrations_lockSubscriptionWhereInput;
}

export interface Knex_migrationsCreateInput {
  batch?: Int;
  migration_time?: DateTimeInput;
  name?: String;
}

export interface Knex_migrations_lockUpdateInput {
  is_locked?: Int;
}

export interface UsersUpdateInput {
  created_at?: DateTimeInput;
  email?: String;
  first_name?: String;
  last_name?: String;
  updated_at?: DateTimeInput;
  username?: String;
}

export interface Knex_migrationsUpdateInput {
  batch?: Int;
  migration_time?: DateTimeInput;
  name?: String;
}

export type Knex_migrations_lockWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface UsersSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UsersWhereInput;
  AND?: UsersSubscriptionWhereInput[] | UsersSubscriptionWhereInput;
  OR?: UsersSubscriptionWhereInput[] | UsersSubscriptionWhereInput;
  NOT?: UsersSubscriptionWhereInput[] | UsersSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UsersConnectionNode {}

export interface UsersConnection
  extends Promise<UsersConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<UsersEdgeNode>>>() => T;
  aggregate: <T = AggregateUsers>() => T;
}

export interface UsersConnectionSubscription
  extends Promise<AsyncIterator<UsersConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<UsersEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateUsersSubscription>() => T;
}

export interface Knex_migrationsEdgeNode {
  cursor: String;
}

export interface Knex_migrationsEdge
  extends Promise<Knex_migrationsEdgeNode>,
    Fragmentable {
  node: <T = Knex_migrations>() => T;
  cursor: () => Promise<String>;
}

export interface Knex_migrationsEdgeSubscription
  extends Promise<AsyncIterator<Knex_migrationsEdgeNode>>,
    Fragmentable {
  node: <T = Knex_migrationsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UsersPreviousValuesNode {
  id: Int;
  created_at: DateTimeOutput;
  email?: String;
  first_name?: String;
  last_name?: String;
  updated_at: DateTimeOutput;
  username?: String;
}

export interface UsersPreviousValues
  extends Promise<UsersPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<Int>;
  created_at: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  first_name: () => Promise<String>;
  last_name: () => Promise<String>;
  updated_at: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
}

export interface UsersPreviousValuesSubscription
  extends Promise<AsyncIterator<UsersPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  first_name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
}

export interface AggregateKnex_migrationsNode {
  count: Int;
}

export interface AggregateKnex_migrations
  extends Promise<AggregateKnex_migrationsNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateKnex_migrationsSubscription
  extends Promise<AsyncIterator<AggregateKnex_migrationsNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Knex_migrations_lockSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface Knex_migrations_lockSubscriptionPayload
  extends Promise<Knex_migrations_lockSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Knex_migrations_lock>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = Knex_migrations_lockPreviousValues>() => T;
}

export interface Knex_migrations_lockSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<Knex_migrations_lockSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = Knex_migrations_lockSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = Knex_migrations_lockPreviousValuesSubscription>() => T;
}

export interface AggregateKnex_migrations_lockNode {
  count: Int;
}

export interface AggregateKnex_migrations_lock
  extends Promise<AggregateKnex_migrations_lockNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateKnex_migrations_lockSubscription
  extends Promise<AsyncIterator<AggregateKnex_migrations_lockNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UsersNode {
  id: Int;
  created_at: DateTimeOutput;
  email?: String;
  first_name?: String;
  last_name?: String;
  updated_at: DateTimeOutput;
  username?: String;
}

export interface Users extends Promise<UsersNode>, Fragmentable {
  id: () => Promise<Int>;
  created_at: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  first_name: () => Promise<String>;
  last_name: () => Promise<String>;
  updated_at: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
}

export interface UsersSubscription
  extends Promise<AsyncIterator<UsersNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  first_name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
}

export interface UsersEdgeNode {
  cursor: String;
}

export interface UsersEdge extends Promise<UsersEdgeNode>, Fragmentable {
  node: <T = Users>() => T;
  cursor: () => Promise<String>;
}

export interface UsersEdgeSubscription
  extends Promise<AsyncIterator<UsersEdgeNode>>,
    Fragmentable {
  node: <T = UsersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UsersSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UsersSubscriptionPayload
  extends Promise<UsersSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Users>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UsersPreviousValues>() => T;
}

export interface UsersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UsersSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UsersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UsersPreviousValuesSubscription>() => T;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Knex_migrations_lockConnectionNode {}

export interface Knex_migrations_lockConnection
  extends Promise<Knex_migrations_lockConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<Knex_migrations_lockEdgeNode>>>() => T;
  aggregate: <T = AggregateKnex_migrations_lock>() => T;
}

export interface Knex_migrations_lockConnectionSubscription
  extends Promise<AsyncIterator<Knex_migrations_lockConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<Knex_migrations_lockEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateKnex_migrations_lockSubscription>() => T;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Knex_migrationsPreviousValuesNode {
  id: Int;
  batch?: Int;
  migration_time?: DateTimeOutput;
  name?: String;
}

export interface Knex_migrationsPreviousValues
  extends Promise<Knex_migrationsPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<Int>;
  batch: () => Promise<Int>;
  migration_time: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface Knex_migrationsPreviousValuesSubscription
  extends Promise<AsyncIterator<Knex_migrationsPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  batch: () => Promise<AsyncIterator<Int>>;
  migration_time: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Knex_migrationsSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface Knex_migrationsSubscriptionPayload
  extends Promise<Knex_migrationsSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Knex_migrations>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = Knex_migrationsPreviousValues>() => T;
}

export interface Knex_migrationsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<Knex_migrationsSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = Knex_migrationsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = Knex_migrationsPreviousValuesSubscription>() => T;
}

export interface Knex_migrations_lockPreviousValuesNode {
  id: Int;
  is_locked?: Int;
}

export interface Knex_migrations_lockPreviousValues
  extends Promise<Knex_migrations_lockPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<Int>;
  is_locked: () => Promise<Int>;
}

export interface Knex_migrations_lockPreviousValuesSubscription
  extends Promise<AsyncIterator<Knex_migrations_lockPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  is_locked: () => Promise<AsyncIterator<Int>>;
}

export interface Knex_migrationsConnectionNode {}

export interface Knex_migrationsConnection
  extends Promise<Knex_migrationsConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<Knex_migrationsEdgeNode>>>() => T;
  aggregate: <T = AggregateKnex_migrations>() => T;
}

export interface Knex_migrationsConnectionSubscription
  extends Promise<AsyncIterator<Knex_migrationsConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<Knex_migrationsEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateKnex_migrationsSubscription>() => T;
}

export interface Knex_migrationsNode {
  id: Int;
  batch?: Int;
  migration_time?: DateTimeOutput;
  name?: String;
}

export interface Knex_migrations
  extends Promise<Knex_migrationsNode>,
    Fragmentable {
  id: () => Promise<Int>;
  batch: () => Promise<Int>;
  migration_time: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface Knex_migrationsSubscription
  extends Promise<AsyncIterator<Knex_migrationsNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  batch: () => Promise<AsyncIterator<Int>>;
  migration_time: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Knex_migrations_lockNode {
  id: Int;
  is_locked?: Int;
}

export interface Knex_migrations_lock
  extends Promise<Knex_migrations_lockNode>,
    Fragmentable {
  id: () => Promise<Int>;
  is_locked: () => Promise<Int>;
}

export interface Knex_migrations_lockSubscription
  extends Promise<AsyncIterator<Knex_migrations_lockNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  is_locked: () => Promise<AsyncIterator<Int>>;
}

export interface Knex_migrations_lockEdgeNode {
  cursor: String;
}

export interface Knex_migrations_lockEdge
  extends Promise<Knex_migrations_lockEdgeNode>,
    Fragmentable {
  node: <T = Knex_migrations_lock>() => T;
  cursor: () => Promise<String>;
}

export interface Knex_migrations_lockEdgeSubscription
  extends Promise<AsyncIterator<Knex_migrations_lockEdgeNode>>,
    Fragmentable {
  node: <T = Knex_migrations_lockSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUsersNode {
  count: Int;
}

export interface AggregateUsers
  extends Promise<AggregateUsersNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUsersSubscription
  extends Promise<AsyncIterator<AggregateUsersNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Type Defs
 */

export const prisma: Prisma;
